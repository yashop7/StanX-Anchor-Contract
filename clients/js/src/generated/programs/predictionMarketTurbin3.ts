/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertIsInstructionWithAccounts,
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT,
  SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
  SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
  SolanaError,
  type Address,
  type ClientWithRpc,
  type ClientWithTransactionPlanning,
  type ClientWithTransactionSending,
  type GetAccountInfoApi,
  type GetMultipleAccountsApi,
  type Instruction,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  addSelfFetchFunctions,
  addSelfPlanAndSendFunctions,
  type SelfFetchFunctions,
  type SelfPlanAndSendFunctions,
} from "@solana/program-client-core";
import {
  getMarketCodec,
  getOrderBookCodec,
  getUserStatsCodec,
  type Market,
  type MarketArgs,
  type OrderBook,
  type OrderBookArgs,
  type UserStats,
  type UserStatsArgs,
} from "../accounts";
import {
  getCancelOrderInstructionAsync,
  getClaimFundsInstructionAsync,
  getClaimRewardsInstructionAsync,
  getCloseMarketInstruction,
  getInitializeMarketInstructionAsync,
  getMarketOrderInstructionAsync,
  getMergeTokensInstruction,
  getPlaceOrderInstructionAsync,
  getSetWinnerInstruction,
  getSplitTokensInstructionAsync,
  getUpdateMetadataInstruction,
  parseCancelOrderInstruction,
  parseClaimFundsInstruction,
  parseClaimRewardsInstruction,
  parseCloseMarketInstruction,
  parseInitializeMarketInstruction,
  parseMarketOrderInstruction,
  parseMergeTokensInstruction,
  parsePlaceOrderInstruction,
  parseSetWinnerInstruction,
  parseSplitTokensInstruction,
  parseUpdateMetadataInstruction,
  type CancelOrderAsyncInput,
  type ClaimFundsAsyncInput,
  type ClaimRewardsAsyncInput,
  type CloseMarketInput,
  type InitializeMarketAsyncInput,
  type MarketOrderAsyncInput,
  type MergeTokensInput,
  type ParsedCancelOrderInstruction,
  type ParsedClaimFundsInstruction,
  type ParsedClaimRewardsInstruction,
  type ParsedCloseMarketInstruction,
  type ParsedInitializeMarketInstruction,
  type ParsedMarketOrderInstruction,
  type ParsedMergeTokensInstruction,
  type ParsedPlaceOrderInstruction,
  type ParsedSetWinnerInstruction,
  type ParsedSplitTokensInstruction,
  type ParsedUpdateMetadataInstruction,
  type PlaceOrderAsyncInput,
  type SetWinnerInput,
  type SplitTokensAsyncInput,
  type UpdateMetadataInput,
} from "../instructions";

export const PREDICTION_MARKET_TURBIN3_PROGRAM_ADDRESS =
  "AA9xwyVDCqHJTSPtigKyvLhaMpgjmU7CCT99SXWt43DP" as Address<"AA9xwyVDCqHJTSPtigKyvLhaMpgjmU7CCT99SXWt43DP">;

export enum PredictionMarketTurbin3Account {
  Market,
  OrderBook,
  UserStats,
}

export function identifyPredictionMarketTurbin3Account(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): PredictionMarketTurbin3Account {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([219, 190, 213, 55, 0, 227, 198, 154]),
      ),
      0,
    )
  ) {
    return PredictionMarketTurbin3Account.Market;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([55, 230, 125, 218, 149, 39, 65, 248]),
      ),
      0,
    )
  ) {
    return PredictionMarketTurbin3Account.OrderBook;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([176, 223, 136, 27, 122, 79, 32, 227]),
      ),
      0,
    )
  ) {
    return PredictionMarketTurbin3Account.UserStats;
  }
  throw new SolanaError(
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT,
    { accountData: data, programName: "predictionMarketTurbin3" },
  );
}

export enum PredictionMarketTurbin3Instruction {
  CancelOrder,
  ClaimFunds,
  ClaimRewards,
  CloseMarket,
  InitializeMarket,
  MarketOrder,
  MergeTokens,
  PlaceOrder,
  SetWinner,
  SplitTokens,
  UpdateMetadata,
}

export function identifyPredictionMarketTurbin3Instruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): PredictionMarketTurbin3Instruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([95, 129, 237, 240, 8, 49, 223, 132]),
      ),
      0,
    )
  ) {
    return PredictionMarketTurbin3Instruction.CancelOrder;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([145, 36, 143, 242, 168, 66, 200, 155]),
      ),
      0,
    )
  ) {
    return PredictionMarketTurbin3Instruction.ClaimFunds;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([4, 144, 132, 71, 116, 23, 151, 80]),
      ),
      0,
    )
  ) {
    return PredictionMarketTurbin3Instruction.ClaimRewards;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([88, 154, 248, 186, 48, 14, 123, 244]),
      ),
      0,
    )
  ) {
    return PredictionMarketTurbin3Instruction.CloseMarket;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([35, 35, 189, 193, 155, 48, 170, 203]),
      ),
      0,
    )
  ) {
    return PredictionMarketTurbin3Instruction.InitializeMarket;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([208, 244, 117, 158, 55, 195, 137, 31]),
      ),
      0,
    )
  ) {
    return PredictionMarketTurbin3Instruction.MarketOrder;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([226, 89, 251, 121, 225, 130, 180, 14]),
      ),
      0,
    )
  ) {
    return PredictionMarketTurbin3Instruction.MergeTokens;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([51, 194, 155, 175, 109, 130, 96, 106]),
      ),
      0,
    )
  ) {
    return PredictionMarketTurbin3Instruction.PlaceOrder;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([207, 149, 39, 13, 31, 233, 182, 109]),
      ),
      0,
    )
  ) {
    return PredictionMarketTurbin3Instruction.SetWinner;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([79, 195, 116, 0, 140, 176, 73, 179]),
      ),
      0,
    )
  ) {
    return PredictionMarketTurbin3Instruction.SplitTokens;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([170, 182, 43, 239, 97, 78, 225, 186]),
      ),
      0,
    )
  ) {
    return PredictionMarketTurbin3Instruction.UpdateMetadata;
  }
  throw new SolanaError(
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
    { instructionData: data, programName: "predictionMarketTurbin3" },
  );
}

export type ParsedPredictionMarketTurbin3Instruction<
  TProgram extends string = "AA9xwyVDCqHJTSPtigKyvLhaMpgjmU7CCT99SXWt43DP",
> =
  | ({
      instructionType: PredictionMarketTurbin3Instruction.CancelOrder;
    } & ParsedCancelOrderInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketTurbin3Instruction.ClaimFunds;
    } & ParsedClaimFundsInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketTurbin3Instruction.ClaimRewards;
    } & ParsedClaimRewardsInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketTurbin3Instruction.CloseMarket;
    } & ParsedCloseMarketInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketTurbin3Instruction.InitializeMarket;
    } & ParsedInitializeMarketInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketTurbin3Instruction.MarketOrder;
    } & ParsedMarketOrderInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketTurbin3Instruction.MergeTokens;
    } & ParsedMergeTokensInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketTurbin3Instruction.PlaceOrder;
    } & ParsedPlaceOrderInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketTurbin3Instruction.SetWinner;
    } & ParsedSetWinnerInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketTurbin3Instruction.SplitTokens;
    } & ParsedSplitTokensInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketTurbin3Instruction.UpdateMetadata;
    } & ParsedUpdateMetadataInstruction<TProgram>);

export function parsePredictionMarketTurbin3Instruction<
  TProgram extends string,
>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedPredictionMarketTurbin3Instruction<TProgram> {
  const instructionType =
    identifyPredictionMarketTurbin3Instruction(instruction);
  switch (instructionType) {
    case PredictionMarketTurbin3Instruction.CancelOrder: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketTurbin3Instruction.CancelOrder,
        ...parseCancelOrderInstruction(instruction),
      };
    }
    case PredictionMarketTurbin3Instruction.ClaimFunds: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketTurbin3Instruction.ClaimFunds,
        ...parseClaimFundsInstruction(instruction),
      };
    }
    case PredictionMarketTurbin3Instruction.ClaimRewards: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketTurbin3Instruction.ClaimRewards,
        ...parseClaimRewardsInstruction(instruction),
      };
    }
    case PredictionMarketTurbin3Instruction.CloseMarket: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketTurbin3Instruction.CloseMarket,
        ...parseCloseMarketInstruction(instruction),
      };
    }
    case PredictionMarketTurbin3Instruction.InitializeMarket: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketTurbin3Instruction.InitializeMarket,
        ...parseInitializeMarketInstruction(instruction),
      };
    }
    case PredictionMarketTurbin3Instruction.MarketOrder: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketTurbin3Instruction.MarketOrder,
        ...parseMarketOrderInstruction(instruction),
      };
    }
    case PredictionMarketTurbin3Instruction.MergeTokens: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketTurbin3Instruction.MergeTokens,
        ...parseMergeTokensInstruction(instruction),
      };
    }
    case PredictionMarketTurbin3Instruction.PlaceOrder: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketTurbin3Instruction.PlaceOrder,
        ...parsePlaceOrderInstruction(instruction),
      };
    }
    case PredictionMarketTurbin3Instruction.SetWinner: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketTurbin3Instruction.SetWinner,
        ...parseSetWinnerInstruction(instruction),
      };
    }
    case PredictionMarketTurbin3Instruction.SplitTokens: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketTurbin3Instruction.SplitTokens,
        ...parseSplitTokensInstruction(instruction),
      };
    }
    case PredictionMarketTurbin3Instruction.UpdateMetadata: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketTurbin3Instruction.UpdateMetadata,
        ...parseUpdateMetadataInstruction(instruction),
      };
    }
    default:
      throw new SolanaError(
        SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
        {
          instructionType: instructionType as string,
          programName: "predictionMarketTurbin3",
        },
      );
  }
}

export type PredictionMarketTurbin3Plugin = {
  accounts: PredictionMarketTurbin3PluginAccounts;
  instructions: PredictionMarketTurbin3PluginInstructions;
};

export type PredictionMarketTurbin3PluginAccounts = {
  market: ReturnType<typeof getMarketCodec> &
    SelfFetchFunctions<MarketArgs, Market>;
  orderBook: ReturnType<typeof getOrderBookCodec> &
    SelfFetchFunctions<OrderBookArgs, OrderBook>;
  userStats: ReturnType<typeof getUserStatsCodec> &
    SelfFetchFunctions<UserStatsArgs, UserStats>;
};

export type PredictionMarketTurbin3PluginInstructions = {
  cancelOrder: (
    input: CancelOrderAsyncInput,
  ) => ReturnType<typeof getCancelOrderInstructionAsync> &
    SelfPlanAndSendFunctions;
  claimFunds: (
    input: ClaimFundsAsyncInput,
  ) => ReturnType<typeof getClaimFundsInstructionAsync> &
    SelfPlanAndSendFunctions;
  claimRewards: (
    input: ClaimRewardsAsyncInput,
  ) => ReturnType<typeof getClaimRewardsInstructionAsync> &
    SelfPlanAndSendFunctions;
  closeMarket: (
    input: CloseMarketInput,
  ) => ReturnType<typeof getCloseMarketInstruction> & SelfPlanAndSendFunctions;
  initializeMarket: (
    input: InitializeMarketAsyncInput,
  ) => ReturnType<typeof getInitializeMarketInstructionAsync> &
    SelfPlanAndSendFunctions;
  marketOrder: (
    input: MarketOrderAsyncInput,
  ) => ReturnType<typeof getMarketOrderInstructionAsync> &
    SelfPlanAndSendFunctions;
  mergeTokens: (
    input: MergeTokensInput,
  ) => ReturnType<typeof getMergeTokensInstruction> & SelfPlanAndSendFunctions;
  placeOrder: (
    input: PlaceOrderAsyncInput,
  ) => ReturnType<typeof getPlaceOrderInstructionAsync> &
    SelfPlanAndSendFunctions;
  setWinner: (
    input: SetWinnerInput,
  ) => ReturnType<typeof getSetWinnerInstruction> & SelfPlanAndSendFunctions;
  splitTokens: (
    input: SplitTokensAsyncInput,
  ) => ReturnType<typeof getSplitTokensInstructionAsync> &
    SelfPlanAndSendFunctions;
  updateMetadata: (
    input: UpdateMetadataInput,
  ) => ReturnType<typeof getUpdateMetadataInstruction> &
    SelfPlanAndSendFunctions;
};

export type PredictionMarketTurbin3PluginRequirements = ClientWithRpc<
  GetAccountInfoApi & GetMultipleAccountsApi
> &
  ClientWithTransactionPlanning &
  ClientWithTransactionSending;

export function predictionMarketTurbin3Program() {
  return <T extends PredictionMarketTurbin3PluginRequirements>(client: T) => {
    return {
      ...client,
      predictionMarketTurbin3: <PredictionMarketTurbin3Plugin>{
        accounts: {
          market: addSelfFetchFunctions(client, getMarketCodec()),
          orderBook: addSelfFetchFunctions(client, getOrderBookCodec()),
          userStats: addSelfFetchFunctions(client, getUserStatsCodec()),
        },
        instructions: {
          cancelOrder: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getCancelOrderInstructionAsync(input),
            ),
          claimFunds: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getClaimFundsInstructionAsync(input),
            ),
          claimRewards: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getClaimRewardsInstructionAsync(input),
            ),
          closeMarket: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getCloseMarketInstruction(input),
            ),
          initializeMarket: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getInitializeMarketInstructionAsync(input),
            ),
          marketOrder: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getMarketOrderInstructionAsync(input),
            ),
          mergeTokens: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getMergeTokensInstruction(input),
            ),
          placeOrder: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getPlaceOrderInstructionAsync(input),
            ),
          setWinner: (input) =>
            addSelfPlanAndSendFunctions(client, getSetWinnerInstruction(input)),
          splitTokens: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getSplitTokensInstructionAsync(input),
            ),
          updateMetadata: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getUpdateMetadataInstruction(input),
            ),
        },
      },
    };
  };
}
